type contractEntryPoints = 
| ["Refill", tez]
| ["Drain"]
;

type storage = nat;
type return_ = [list<operation>, storage];


let refill = ([store, n] : [storage, tez]) : storage => {
  if (Tezos.amount != n) {
    failwith("Transferred token amount does not match the parameter") as storage
  } else {
    if (Tezos.amount > (0 as tez)) {
      return (store + (1 as nat));
    } else {
      return store;
    }
    
  }
}

let drain = (_store: storage) : storage => {
  if (Tezos.amount > (0 as tez)) {
    failwith ("Sending token when calling drain is not allowed") as storage
  } else {
    n_store = (0 as nat);
    return n_store;
  }
}

let main = ([action, store]: [contractEntryPoints, storage]): return_ => {

  let operations: list<operation> = (list([]) as list<operation>);

  let receiver : contract<unit> =
    match (Tezos.get_contract_opt(Tezos.sender) as option<contract<unit>>, {
      Some: (contract: contract<unit>) => contract,
      None: () => (failwith("no contract") as contract<unit>)
    });

  let operations_ : list<operation> = match (action, {
    Refill: (_n: tez) => operations,
    Drain : () => list([Tezos.transaction(unit, Tezos.balance, receiver), ...operations]),
  });

  return [
    operations_,
    match (action, {
      Refill: (n: tez) => refill ([store, n]),
      Drain : () => drain (store)
    })
  ];

}
