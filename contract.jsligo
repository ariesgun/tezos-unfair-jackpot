type contractEntryPoints = 
| ["Refill", tez]
| ["Drain"]
;

type storage = nat;

type return_ = [list<operation>, storage];

let refill = ([store, n] : [storage, tez]) : storage => {

  if (Tezos.amount != n) {
    failwith("Transferred token amount does not match the parameter") as storage
  } else {
    if (Tezos.amount > (0 as tez)) {
      return (store + (1 as nat));
    } else {
      return store;
    }
    
  }
}

let drain = (store: storage) : storage => {

  if (Tezos.amount > (0 as tez)) {
    failwith ("Sending token when calling drain is not allowed") as storage
  } else {
    return store;
  }
}

let main = ([action, store]: [contractEntryPoints, storage]): return_ => {

  return [
    (list([]) as list<operation>),
    match (action, {
      Refill: (n: tez) => refill ([store, n]),
      Drain : () => drain (store)
    })
  ];

}
